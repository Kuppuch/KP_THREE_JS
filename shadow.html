<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow</title>
    <script src="old/three.js"></script>
    <script src="old/TrackballControls.js"></script>
</head>

<body>
    <canvas id="c" width="1240" height="870"></canvas>

    <script>
        var Key = {
            _pressed: {},

            A: 65,
            W: 87,
            D: 68,
            S: 83,
            SPACE: 32,
            Ctrl: 17,

            isDown: function (keyCode) {
                return this._pressed[keyCode];
            },
            onKeydown: function (event) {
                this._pressed[event.keyCode] = true;
            },
            onKeyup: function (event) {
                delete this._pressed[event.keyCode];
            }
        }

        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({
            canvas
        });
        renderer.shadowMapEnabled = true;



        const aspect = 2; // the canvas default
        const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        camera.position.y = 50;
        camera.position.z = 300;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        var controls = new THREE.TrackballControls(camera, canvas);
        controls.rotateSpeed = 2;
        controls.noZoom = false;
        controls.zoomSpeed = 1.2;
        controls.staticMoving = true;

        const scene = new THREE.Scene();

        light = new THREE.DirectionalLight(0xffffff);
        light.position.set(0, 100, 0);
        light.castShadow = true;
        scene.add(light);

        light2 = new THREE.DirectionalLight(0xffffff);
        light2.position.set(0, -100, 0);
        // light2.castShadow = true;
        scene.add(light2);



        var material = new THREE.MeshLambertMaterial({
            color: 0x33CCFF
        });

        // var geometry = new THREE.SphereGeometry(20, 50, 50);
        // var sphere1 = new THREE.Mesh(geometry, material);
        // sphere1.position.set(0, 60, 0);
        // sphere1.castShadow = true;
        // scene.add(sphere1);

        var planeMaterial1 = new THREE.MeshLambertMaterial({
            color: 0x9999ff,
            side: THREE.DoubleSide
        });
        var planGeo1 = new THREE.PlaneGeometry(200, 200, 1, 1);
        var plane1 = new THREE.Mesh(planGeo1, planeMaterial1);
        plane1.rotation.x = Math.PI / 2;
        plane1.receiveShadow = true;
        plane1.castShadow = true;
        scene.add(plane1);

        var planeMaterial2 = new THREE.MeshLambertMaterial({
            color: 0xff00ff,
            side: THREE.DoubleSide
        });
        var planGeo2 = new THREE.PlaneGeometry(300, 300, 1, 1);
        var plane2 = new THREE.Mesh(planGeo2, planeMaterial2);
        plane2.position.set(0, 120, 0);
        plane2.rotation.x = Math.PI / 2;
        plane2.receiveShadow = true;
        scene.add(plane2);

        function dynamo() {
            if (Key.isDown(Key.A)) // движение влево
            {
                light.position.x -= 0.1;
            }
            if (Key.isDown(Key.D)) // движение вправо
            {
                light.position.x += 0.1;
            }
            if (Key.isDown(Key.W)) // движение вперёд
            {
                light.position.z -= 0.1;
            }
            if (Key.isDown(Key.S)) // движение назад
            {
                light.position.z += 0.1;
            }
            if (Key.isDown(Key.SPACE)) // подскок
            {
                light.position.y += 0.1;
            }
            if (Key.isDown(Key.Ctrl)) // подскок
            {
                light.position.y -= 0.1;
            }
        }



        // function resizeRendererToDisplaySize(renderer) {
        //     const canvas = renderer.domElement;
        //     const width = canvas.clientWidth;
        //     const height = canvas.clientHeight;
        //     const needResize = canvas.width !== width || canvas.height !== height;
        //     if (needResize) {
        //         renderer.setSize(width - 20, height, false);
        //     }
        //     return needResize;
        // }

        function render(time) {
            time *= 0.001;

            // if (resizeRendererToDisplaySize(renderer)) {
            //     const canvas = renderer.domElement;
            //     camera.aspect = canvas.clientWidth / canvas.clientHeight;
            //     camera.updateProjectionMatrix();
            // }

            dynamo();
            controls.update();

            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        window.addEventListener('keyup', function (event) {
                Key.onKeyup(event);
            },
            false
        );

        window.addEventListener('keydown', function (event) {
                Key.onKeydown(event);
            },
            false
        );
    </script>
</body>

</html>