<!DOCTYPE html>

<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Three.js - Custom Geometry - Cube - face normals</title>
    <style>
        body {
            margin: 0;
        }

        #c {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="c" width="1246" height="880"></canvas>

    <script src="old/three.js"></script>
    <script>
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({
            canvas
        });

        const aspect = 2; // the canvas default
        const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100);
        camera.position.y = 0;
        camera.position.z = 5;


        const scene = new THREE.Scene();

        {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(-1, 2, 4);
            scene.add(light);
        }

        const geometry = new THREE.Geometry();
        geometry.vertices.push(
            new THREE.Vector3(-1, -1, 1.5), // 0
            new THREE.Vector3(-1, -0.75, 1.5), // 1
            new THREE.Vector3(1, -0.75, 1.5), // 2
            new THREE.Vector3(1, -1, 1.5), // 3

            new THREE.Vector3(-1, -1, -1), // 4
            new THREE.Vector3(1, -1, -1), // 5

            new THREE.Vector3(-1, -1, 1), // 6
            new THREE.Vector3(1, -1, 1), // 7

            new THREE.Vector3(-1, -0.75, 1), // 8
            new THREE.Vector3(1, -0.75, 1), // 9

            new THREE.Vector3(-1, 1, 1), // 10
            new THREE.Vector3(1, 1, 1), // 11
              new THREE.Vector3(-1, 1, -1), // 12
              new THREE.Vector3(1, 1, -1), // 13
            //   new THREE.Vector3(-1, 1, -1), // 8
            //   new THREE.Vector3(1, 1, -1), // 9
        );

        /*
             6----7
            /|   /|
           2----3 |
           | |  | |
           | 4--|-5
           |/   |/
           0----1
        */

        geometry.faces.push(

            new THREE.Face3(2, 1, 0),
            new THREE.Face3(0, 3, 2),

            //дно
            new THREE.Face3(5, 0, 4),
            new THREE.Face3(0, 5, 3),
            // конец дна

            new THREE.Face3(9, 1, 2),
            new THREE.Face3(9, 8, 1),

            new THREE.Face3(0, 1, 8),
            new THREE.Face3(9, 2, 3),
            new THREE.Face3(8, 6, 0),
            new THREE.Face3(3, 7, 9),

            new THREE.Face3(9, 10, 8),
            new THREE.Face3(9, 11, 10),

            // крышка
            new THREE.Face3(13, 12, 10),
            new THREE.Face3(13, 10, 11),

            // зад
            new THREE.Face3(4, 12, 13),
            new THREE.Face3(4, 13, 5),


            // слева
            new THREE.Face3(12, 4, 6),
            new THREE.Face3(6, 10, 12),

            // справа
            new THREE.Face3(7, 5, 13),
            new THREE.Face3(13, 11, 7),

        );

        geometry.computeFaceNormals();

        function makeInstance(geometry, color, x) {
            const material = new THREE.MeshPhongMaterial({
                color
            });

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            cube.position.x = x;
            return cube;
        }

        const cubes = [
            makeInstance(geometry, 0x4444FF, 0),
        ];

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }

        function render(time) {
            time *= 0.001;

            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }

            cubes.forEach((cube, ndx) => {
                const speed = 1 + ndx * .1;
                const rot = time * speed;
                // cube.rotation.x = rot;
                cube.rotation.x = rot;
            });

            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>


</body>

</html>